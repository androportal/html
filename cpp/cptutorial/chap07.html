<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <TITLE>C/C++ Programming</TITLE>
</HEAD>
<BODY>

<A NAME="chap07.html">
<H1>Chapter 7 Arrays</H1>
</A>

The concept of an array is common to most programming languages.  
In an array, multiple values of the same data type can be stored 
with one variable name.  The use of arrays allows for the 
development of smaller and more clearly readable programs. 

<H3>7.1 Arrays</H3>

Arrays are classified as aggregate data types.  Unlike atomic 
data types which cannot be subdivied, aggregate data types are 
composed of one or more elements of an atomic or another 
aggregate data type.  Simply put aggregate data types can be 
subdivided or broken down.  To access individual elements of an 
array a subscript must be used.  The subscript identifies the 
sub-element or component of the array that is to be accessed.  
Subscripts must start at <B>0</B> and proceed in increments of 1.  
Arrays can be of any data type supported by <B>C</B>, including 
constructed data types and arrays can be of any storage class 
except 'register'.

<H3>7.1.1 Declaring and Initialization</H3>

Arrays can be declared as local variables or global variables.  
Initialization of an array when it is declared is allowed for 
both locally and globally declared arrays.  Initializing an array 
when it is declared does not require the presence of a dimension 
on the array 

<H4>Fig. 7-1</H4>
<BR>
<PRE>
    char name[] = "John Smith";
    int age[] = {21,32,43,22,25};
    main()
    {
         .
         .
         .
    }

    OR

    main()
    {
    int age[] = {21,32,43,22,25};
         .
         .
         .
    }
</PRE>
<BR>
If an array is declared to hold ten elements, the subscripts 
start at <B>0</B> and the highest subscript allowed for that array is <B>9</B>.  
There is no bounds checking on arrays.  It is the programmers 
responsibility to keep the subscript within the bounds of the 
array.  On the above array <B>age</B>, which has five elements if a
statement such as 
<BR>
<PRE>
    age[6] = 10;
</PRE>
<BR>
is made in the program, no error or warning will be generated by 
the compiler.  The array <B>age</B> should only support subscripts
ranging from <B>0</B> to <B>5</B>.  A subscript of <B>6</B> is not within the bounds 
of the array, but <B>C/C++</B> will allow the statement.  In most cases 
the program will terminate with a runtime error because of the 
above statement.

<H3>7.1.2 Multi-Dimensional Arrays</H3>

Two and three dimensional arrays are allowed but actually there 
is no limit on the number of dimensions for an array. 
<BR>
<PRE>
    int aver[10][20];

    float sales[50][10][2];
</PRE>
<BR>
Values in a multi-dimensional array are stored in row-major 
order, meaning that if array is declared as 
<BR>
<PRE>
    int data[3][4];
</PRE>
<BR>
the values are stored in memory in this order
<BR>
<PRE>
[0][0] [0][1] [0][2] [0][3] [1][0] [1][1] [1][2] [1][3] ...
</PRE>
<BR>
and so forth.  Therefore, when initializing a multi-dimensional 
array at declaration time, the row designator does not have to be 
stated, but the column length must be stated, such as:
<BR>
<PRE>
    float monthlySalesByProduct[][4] = 
         { {100.50, 234.32, 987.98}
         , {324.56, 123.43, 876.83}
         , {765.23, 8743.28, 27388.87}
         ...
         };
</PRE>
<BR>
Notice the use of nested <B>{...}</B> pairs to set off the column values
for a row.  This is required in order to delineate the boundaries 
of the rows.  The two-dimensional array above can also be called 
a square array.  A square array can be used to store arrays of 
strings.  

<H4>Listing 7-1</H4>
<BR>
<PRE>
#include &lt;iostream.h&gt;

int main()
{
char students[10][25];   // holds names of students 
int idx;

    for( idx = 0; idx < 10; ++idx )
    {
         cout << "Enter a students first name: ";
         cin >> students[idx];
    }

    cout << "\nThe students in the class are:" << endl;

    for( idx = 0; idx < 10; ++idx )
         cout << students[idx] << endl;
    return 0;
}
</PRE>
<BR>
Notice the used of <B>students[i]</B> in the above example.  The name of
each row in the multi-dimensional array is the name of an array, 
which means that it represents the beginning address of where 
data is stored.  You can use the name of a row the same as you 
would the name of an array.  Also, notice that no matter how 
short the name of the student is, the same number of characters 
is allocated for each row, therefore leading to excessing use of 
memory space.

<H3>7.2 Arrays as Arguments</H3>

Arrays are automatically passed by reference to a function.  The 
name of an array is the beginning address of where the array data 
is stored in memory; also known as a 'pointer constant'.

<H4>Listing 7-2</H4>
<BR>
<PRE>
#include &lt;iostream.h&gt;

int main()
{
int list[10]
    ,max = 10
    ,indx = 0
    ,largest
    ,num_ele
    ;
int find_max( int [], int );

    while( indx < max)
    {
         cout << "\nEnter a number: ";
         cin >> list[indx];
         ++indx;
    }
    largest = find_max( list, max );
    cout << "\nLargest number is " << largest << endl;
    return 0;
}
    
int find_max( int list2[], int size )
{
int 
    idx
    ,highest
    ;

    for(highest = list2[0],idx = 1; idx < size; ++idx)
         if(highest < list2[idx])
              highest = list2[idx];
    return(highest);
}
</PRE>
<BR>
In the <B>find_max()</B> function, <B>list2[]</B> is an array of undetermined
length.  On the call to <B>find_max()</B> the argument <B>list</B> is stated 
without subscripts, this passes the address of <B>list</B>, because 
<B>list</B> is an array.  The name of an array is a pointer constant
that represents the beginning address of the array.  Therefore, 
when <B>list</B> is stated in the call to <B>find_max()</B>, the address that
<B>list</B> represents is actually passed to the function.  The
receiving argument <B>list2[]</B> only receives the address of where the
array begins in memory.  With the array notation used for the 
receiving argument, <B>list2[]</B> can be treated as if it is an alias
that allows for the direct manipulation of the data stored in 
<B>list</B>.

Multi Dimensional arrays as arguments follow the same syntax 
except that on the receiving side the last dimension must be 
stated.  This is so the compiler knows where one row of data ends 
and another row begins.

<H4>Listing 7-3</H4>
<BR>
<PRE>
#include &lt;iostream.h&gt;

#define ROWS        10
#define COLUMNS     2

int main()
{
float agents[ROWS][COLUMNS];
int indx = 0;
int maxex( float [][COLUMNS], int );

    cout << "\nEnter 3-digit agent"
         << " number then travel "
         << "expenses(001 1642.50)";
    do 
    {
         cout << "\nAgents # and expenses:";
         cin >> agents[indx][0]
             >> agents[indx][1]);
    }while( agents[indx++][0] != 0 );

    indx--;
    indx = maxex(agents,indx);
    cout << "\nAgent with highest expenses: "
         << agents[indx][0];
    cout << "   Amount: %.2f"
         << agents[indx][1];
    return 0;
}

int maxex(float list[][COLUMNS],int size)
{ 
int 
    idx
    ,maxidx
    ;
float 
    max
    ;
         
    max = list[0][1];
    maxidx = 0;
    for(idx = 1; idx <size; idx++)
         if(max < list[idx][1])
         {
              max = list[idx][1];
              maxidx = idx;
         }
    return(maxidx);
}
</PRE>
<BR>
<H4>7.3 Strings</H4>

An array of type char ending with a NULL ('\000') character is 
called a string in <B>C</B>.

<H4>Fig 7-3</H4>
<BR>
<PRE>
    char name[] = "John Smith";
    main()
    {
         .
         .
         .
    }
</PRE>
<BR>
the above string is stored in memory as:

<H4>Fig 7-4</H4>
<BR>
<PRE>
         memory        value
         address       at address

          2000           J
          2001           o
          2002           h
          2003           n
          2004
          2005           S
          2006           m
          2007           i
          2008           t
          2009           h
          200A           \0
</PRE>
<BR>
An array that will be used as a string must be declared with one 
additional byte more than is needed for data.  This allots space 
for the NULL byte which is the signal indicating the end of the 
string. 

<H4>Listing 7-4</H4>
<BR>
<PRE>
//
//    looks at string in memory
//
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
char name[81];
int indx;

    cout << "\nEnter your name: ";
    gets(name);    // used because of whitespace input
    cout << "\nThe string " << name
         << " is stored at address " 
         << hex << unsigned(name);

    for(indx=0; indx < strlen(name); ++indx)
    {
         cout << "\nADDR: " << hex << unsigned(name);
         cout << " CHAR: "  << name[indx];
         cout << " DEC:  " << dec <<  int(name[indx]);
    }
    return 0;
}
</PRE>
<BR>
<H3>7.3.1 String Functions<</H3>

Strings must be manipulated with standard functions supplied with 
the compiler function libraries.
<PRE>
<B>char *strcat(char *str1, char *str2);</B>
</PRE>
Appends str2 to str1, terminates the resulting string with a NULL 
character and returns the address of the concatenated string, 
str1. 
<PRE>
<B>char *strchr(char *str, char c);</B>
</PRE>
Returns the address of the first occurrence of <B>c</B> in <B>str</B>; the 
function returns NULL if the character is not found. 
<PRE>
<B>int strcmp(char *str1, char *str2);</B>
</PRE>
Compares <B>str1</B> and <B>str2</B> lexicographically and returns a value 
indicating their relationship.
<BR>
<PRE>
                   Value          Meaning

                    < 0       str1 less than str2
                    0         str1 equal to str2
                    > 0       str1 greater than str2

<B>int strcmpi(char *str1, char *str2);</B>
</PRE>
Case-insensitive version of strcmp. Strings are compared without 
regard to case.
<PRE>
<B>char *strcpy(char *str1, char *str2);</B>
</PRE>
Copies <B>str2</B>, including the null terminating character to location 
specified by <B>str1</B> and returns <B>str1</B>. 
<PRE>
<B>int strcspn(char *str1, char *str2);</B>
</PRE>
Returns the index of the first character in <B>str1</B> that belongs to 
the set of characters specified by <B>str2</B>.
<PRE>
<B>char *strdup(char *str);</B>
</PRE>
Allocates storage space for a copy of <B>str</B> and returns the address 
to that storage space containing the copied string.  Returns NULL 
if storage could not be found.
<PRE>
<B>int strlen(char *str);</B>
</PRE>
Returns the length in bytes of <B>str</B> not including the 
termininating null character. 
<PRE>
<B>char *strlwr(char *str);</B>
</PRE>
Converts any uppercase letters in the given null terminated 
string to lowercase. 
<PRE>
<B>char *strncat(char *str1, char *str2, int n);</B>
</PRE>
Appends at most the first <B>n</B> characters of <B>str2</B> to <B>str1</B>, 
terminates the resulting string with a null character and returns 
the address of the concatenated <B>str1</B>. 
<PRE>
<B>int strncmp(char *str1, char *str2, int n);</B>
</PRE>
Compares at most the first <B>n</B> characters of <B>str1</B> and <B>str2</B> 
lexicographically and returns a value indicating the relationship 
between the substrings. 
<PRE>
                   Value     Meaning

                   < 0       substring1 < substring2
                   0         substring1 = substring2
                   > 0       substring1 > substring2

<B>char *strncpy(char *str1, char * str2, int n);</B>
</PRE>
Copies exactly <B>n</B> characters of <B>str2</B> to <B>str1</B> and returns <B>str1</B>. 
<PRE>
<B>char *strnset(char *str, char c, int n);</B>
</PRE>
Sets at most the first <B>n</B> characters of <B>str</B> to the character <B>c</B> 
and returns the address of the altered <B>str</B>. 
<PRE>
<B>char *strtok( char *str, char *delims );</B>
</PRE>
Searches one string for tokens, which are separated by delimiters 
defined in a second string. 

<H4>Listing 7-5</H4>
<PRE>
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
char input[16] = "abc,d";
char *p;

    /*
    *    strtok places a NULL terminator
    *    in front of the token, if found 
    */
    p = strtok( input, "," );
    if( p )
         printf( "%s\n", p);
    /*
    *    a second call to strtok using a 
    *    NULL as the first parameter returns 
    *    a pointer to the character following
    *    the token
    */
    p = strtok( NULL, "," );
    if( p )
         printf("%s\n", p );
    return 0;
}
</PRE>
